import { GoogleGenerativeAI } from '@google/generative-ai';
import Anthropic from '@anthropic-ai/sdk';
import OpenAI from 'openai';
import { HfInference } from '@huggingface/inference';
import crypto from 'crypto';
import fs from 'fs';
import path from 'path';
import readline from 'readline';
import os from 'os';

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//  PROVIDER REGISTRY
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

export const PROVIDERS = {
  gemini: {
    name: 'Google Gemini',
    envKey: 'GEMINI_API_KEY',
    defaultModel: 'gemini-2.0-flash',
    models: ['gemini-2.0-flash', 'gemini-2.0-flash-lite', 'gemini-2.5-pro-preview-05-06'],
    keyUrl: 'https://aistudio.google.com/app/apikey',
  },
  openai: {
    name: 'OpenAI',
    envKey: 'OPENAI_API_KEY',
    defaultModel: 'gpt-4o',
    models: ['gpt-4o', 'gpt-4o-mini', 'gpt-4.1', 'gpt-4.1-mini', 'o3-mini'],
    keyUrl: 'https://platform.openai.com/api-keys',
  },
  anthropic: {
    name: 'Anthropic Claude',
    envKey: 'ANTHROPIC_API_KEY',
    defaultModel: 'claude-sonnet-4-5-20250929',
    models: ['claude-sonnet-4-5-20250929', 'claude-opus-4-5-20250929', 'claude-3-5-haiku-20241022'],
    keyUrl: 'https://console.anthropic.com/settings/keys',
  },
  huggingface: {
    name: 'Hugging Face',
    envKey: 'HF_API_KEY',
    defaultModel: 'mistralai/Mistral-Small-24B-Instruct-2501',
    models: [
      'mistralai/Mistral-Small-24B-Instruct-2501',
      'Qwen/Qwen2.5-72B-Instruct',
      'meta-llama/Llama-3.3-70B-Instruct',
    ],
    keyUrl: 'https://huggingface.co/settings/tokens',
  },
};

// Active provider state
let activeProvider = null;   // 'gemini' | 'openai' | 'anthropic' | 'huggingface'
let activeClient = null;
let activeModel = null;
let conversationMessages = []; // universal message buffer
let systemPromptCache = '';

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//  SECURE KEYSTORE  (per-provider, encrypted)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

const KEYSTORE_NAME = '.babok_keystore';

function deriveSecret() {
  const material = `babok::${os.hostname()}::${os.userInfo().username}::${process.cwd()}`;
  return crypto.createHash('sha256').update(material).digest();
}

function xorCipher(buf, key) {
  const out = Buffer.alloc(buf.length);
  for (let i = 0; i < buf.length; i++) out[i] = buf[i] ^ key[i % key.length];
  return out;
}

function getKeystorePath() {
  return path.join(process.cwd(), KEYSTORE_NAME);
}

function readKeystore() {
  const ksPath = getKeystorePath();
  if (!fs.existsSync(ksPath)) return {};
  try {
    return JSON.parse(fs.readFileSync(ksPath, 'utf-8'));
  } catch { return {}; }
}

function writeKeystore(data) {
  data._WARNING = 'Auto-generated by BABOK CLI. Do NOT commit to git.';
  data.updated_at = new Date().toISOString();
  fs.writeFileSync(getKeystorePath(), JSON.stringify(data, null, 2), 'utf-8');
}

/**
 * Read stored API key for a specific provider.
 */
export function readStoredKey(provider) {
  const ks = readKeystore();
  const entry = ks[provider];
  if (!entry?.k) return null;
  try {
    const encrypted = Buffer.from(entry.k, 'base64');
    const decrypted = xorCipher(encrypted, deriveSecret()).toString('utf-8');
    if (decrypted.length >= 8 && /^[A-Za-z0-9_\-:.]+$/.test(decrypted)) return decrypted;
    return null;
  } catch { return null; }
}

/**
 * Store API key for a specific provider (encrypted).
 */
export function storeKey(provider, apiKey) {
  const ks = readKeystore();
  ks[provider] = {
    k: xorCipher(Buffer.from(apiKey, 'utf-8'), deriveSecret()).toString('base64'),
    stored_at: new Date().toISOString(),
  };
  writeKeystore(ks);
}

/**
 * Remove stored key for a provider (or all).
 */
export function clearStoredKey(provider) {
  if (!provider) {
    const ksPath = getKeystorePath();
    if (fs.existsSync(ksPath)) fs.unlinkSync(ksPath);
    return;
  }
  const ks = readKeystore();
  delete ks[provider];
  writeKeystore(ks);
}

/**
 * List providers that have stored keys.
 */
export function listStoredProviders() {
  const ks = readKeystore();
  return Object.keys(PROVIDERS).filter(p => ks[p]?.k);
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//  API KEY RESOLUTION  (env â†’ .env â†’ keystore)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

/**
 * Get API key for a provider without prompting.
 */
export function getApiKey(provider) {
  const info = PROVIDERS[provider];
  if (!info) return null;

  // 1. Environment variable
  if (process.env[info.envKey]) return process.env[info.envKey];

  // 2. .env file (gitignored)
  const envPath = path.join(process.cwd(), '.env');
  if (fs.existsSync(envPath)) {
    const content = fs.readFileSync(envPath, 'utf-8');
    const match = content.match(new RegExp(`^${info.envKey}\\s*=\\s*(.+)$`, 'm'));
    if (match?.[1]?.trim()) return match[1].trim().replace(/^["']|["']$/g, '');
  }

  // 3. Encrypted keystore
  return readStoredKey(provider);
}

/**
 * Interactively select provider and enter API key.
 */
export function promptForProvider() {
  return new Promise((resolve, reject) => {
    const rl = readline.createInterface({ input: process.stdin, output: process.stdout });

    const stored = listStoredProviders();
    const providerList = Object.entries(PROVIDERS);

    process.stdout.write('\n');
    process.stdout.write('  ðŸ”Œ Select AI provider:\n\n');
    providerList.forEach(([key, info], i) => {
      const badge = stored.includes(key) ? chalk_green(' [key saved]') : '';
      process.stdout.write(`     ${i + 1}. ${info.name}${badge}\n`);
    });
    process.stdout.write('\n');

    rl.question('  Enter number (1-4): ', (num) => {
      const idx = parseInt(num) - 1;
      if (isNaN(idx) || idx < 0 || idx >= providerList.length) {
        rl.close();
        reject(new Error('Invalid provider selection.'));
        return;
      }
      const [providerKey, info] = providerList[idx];

      // Check if we already have a key
      const existingKey = getApiKey(providerKey);
      if (existingKey) {
        rl.question(`  Use saved ${info.name} key? (Y/n): `, (ans) => {
          if (!ans.trim() || ans.trim().toLowerCase().startsWith('y')) {
            rl.close();
            resolve({ provider: providerKey, apiKey: existingKey });
            return;
          }
          askForKey(rl, providerKey, info, resolve, reject);
        });
        return;
      }
      askForKey(rl, providerKey, info, resolve, reject);
    });
  });
}

function askForKey(rl, providerKey, info, resolve, reject) {
  process.stdout.write('\n');
  process.stdout.write(`  ðŸ”‘ ${info.name} API key required.\n`);
  process.stdout.write(`     Get one at: ${info.keyUrl}\n\n`);
  process.stdout.write('     Your key is stored ONLY locally (encrypted, gitignored).\n');
  process.stdout.write('     It will NEVER be committed to the repository.\n\n');

  rl.question('  Enter API key: ', (apiKey) => {
    const key = apiKey.trim();
    if (!key) { rl.close(); reject(new Error('No API key provided.')); return; }

    rl.question('  Save key for future sessions? (Y/n): ', (ans) => {
      rl.close();
      if (!ans.trim() || ans.trim().toLowerCase().startsWith('y')) {
        storeKey(providerKey, key);
        process.stdout.write('  âœ“ Key saved to .babok_keystore (encrypted, gitignored)\n\n');
      } else {
        process.stdout.write('  âœ“ Key used for this session only (not saved)\n\n');
      }
      resolve({ provider: providerKey, apiKey: key });
    });
  });
}

// simple green text without chalk dependency in this module
function chalk_green(s) { return `\x1b[32m${s}\x1b[0m`; }

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//  UNIFIED CLIENT INIT & CHAT
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

/**
 * Initialize the selected provider.
 */
export function initializeProvider(provider, apiKey, modelName) {
  const info = PROVIDERS[provider];
  if (!info) throw new Error(`Unknown provider: ${provider}`);
  const model = modelName || info.defaultModel;

  switch (provider) {
    case 'gemini': {
      const genAI = new GoogleGenerativeAI(apiKey);
      activeClient = genAI.getGenerativeModel({ model });
      break;
    }
    case 'openai': {
      activeClient = new OpenAI({ apiKey });
      break;
    }
    case 'anthropic': {
      activeClient = new Anthropic({ apiKey });
      break;
    }
    case 'huggingface': {
      activeClient = new HfInference(apiKey);
      break;
    }
  }

  activeProvider = provider;
  activeModel = model;
  conversationMessages = [];
}

/**
 * Start chat session (sets system prompt, optionally loads history).
 */
export function startChatSession(systemPrompt, history = []) {
  systemPromptCache = systemPrompt;
  conversationMessages = [...history];
}

/**
 * Send message and stream response (provider-agnostic).
 */
export async function sendMessageStream(message, onChunk) {
  conversationMessages.push({ role: 'user', parts: [{ text: message }] });

  let fullResponse = '';

  switch (activeProvider) {
    case 'gemini': {
      const chat = activeClient.startChat({
        history: conversationMessages.slice(0, -1),
        systemInstruction: systemPromptCache,
        generationConfig: { maxOutputTokens: 8192, temperature: 0.7 },
      });
      const result = await chat.sendMessageStream(message);
      for await (const chunk of result.stream) {
        const text = chunk.text();
        fullResponse += text;
        if (onChunk) onChunk(text);
      }
      break;
    }

    case 'openai': {
      const messages = [
        { role: 'system', content: systemPromptCache },
        ...conversationMessages.map(m => ({
          role: m.role === 'model' ? 'assistant' : m.role,
          content: m.parts[0].text,
        })),
      ];
      const stream = await activeClient.chat.completions.create({
        model: activeModel,
        messages,
        stream: true,
        max_tokens: 8192,
        temperature: 0.7,
      });
      for await (const chunk of stream) {
        const text = chunk.choices?.[0]?.delta?.content || '';
        fullResponse += text;
        if (onChunk && text) onChunk(text);
      }
      break;
    }

    case 'anthropic': {
      const messages = conversationMessages.map(m => ({
        role: m.role === 'model' ? 'assistant' : m.role,
        content: m.parts[0].text,
      }));
      const stream = activeClient.messages.stream({
        model: activeModel,
        system: systemPromptCache,
        messages,
        max_tokens: 8192,
        temperature: 0.7,
      });
      for await (const event of stream) {
        if (event.type === 'content_block_delta' && event.delta?.text) {
          fullResponse += event.delta.text;
          if (onChunk) onChunk(event.delta.text);
        }
      }
      break;
    }

    case 'huggingface': {
      const messages = [
        { role: 'system', content: systemPromptCache },
        ...conversationMessages.map(m => ({
          role: m.role === 'model' ? 'assistant' : m.role,
          content: m.parts[0].text,
        })),
      ];
      const stream = activeClient.chatCompletionStream({
        model: activeModel,
        messages,
        max_tokens: 8192,
        temperature: 0.7,
      });
      for await (const chunk of stream) {
        const text = chunk.choices?.[0]?.delta?.content || '';
        fullResponse += text;
        if (onChunk && text) onChunk(text);
      }
      break;
    }

    default:
      throw new Error(`Provider ${activeProvider} not initialized`);
  }

  conversationMessages.push({ role: 'model', parts: [{ text: fullResponse }] });
  return fullResponse;
}

/**
 * Get active provider info for display.
 */
export function getActiveProviderInfo() {
  return {
    provider: activeProvider,
    model: activeModel,
    name: PROVIDERS[activeProvider]?.name || activeProvider,
  };
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//  PROMPT LOADING
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

export function loadStagePrompt(stageNumber) {
  const possiblePaths = [
    path.join(process.cwd(), 'BABOK_AGENT', 'stages', `BABOK_agent_stage_${stageNumber}.md`),
    path.join(process.cwd(), 'BABOK_AGENT', 'BABOK_Agent_System_Prompt.md'),
  ];
  for (const p of possiblePaths) {
    if (fs.existsSync(p)) return fs.readFileSync(p, 'utf-8');
  }
  return getGenericStagePrompt(stageNumber);
}

export function loadMainSystemPrompt() {
  const possiblePaths = [
    path.join(process.cwd(), 'BABOK_AGENT', 'BABOK_Agent_System_Prompt.md'),
    path.join(process.cwd(), 'BABOK_AGENT_SYSTEM_PROMPT.md'),
  ];
  for (const p of possiblePaths) {
    if (fs.existsSync(p)) return fs.readFileSync(p, 'utf-8');
  }
  return '';
}

function getGenericStagePrompt(stageNumber) {
  const stageNames = {
    1: 'Project Initialization & Stakeholder Mapping',
    2: 'Current State Analysis (AS-IS)',
    3: 'Problem Domain Analysis',
    4: 'Solution Requirements Definition',
    5: 'Future State Design (TO-BE)',
    6: 'Gap Analysis & Implementation Roadmap',
    7: 'Risk Assessment & Mitigation Strategy',
    8: 'Business Case & ROI Model',
  };
  return `You are BABOK Agent, an expert Business Analyst specializing in IT projects.

Currently working on: Stage ${stageNumber} - ${stageNames[stageNumber]}

Guidelines:
- Ask clarifying questions when needed
- Provide evidence-based analysis
- Wait for human validation before proceeding to deliverables
- Use Polish language for responses when user writes in Polish
- Follow BABOK v3 methodology`;
}
